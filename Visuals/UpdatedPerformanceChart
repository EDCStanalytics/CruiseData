<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 CallData Seasonality View (Centered Clusters)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .conn { fill: pink; stroke: black; rx: 6; ry: 6; }
    .ad {}
    .after { fill: black; }
    .before { fill: blue; }
    select { margin: 20px; padding: 5px; }
  </style>
</head>
<body>
 <label for="vesselSelect">Select Vessel:</label>
  <select id="vesselSelect"></select>
  <svg id="chart" width="4000" height="600"></svg>

  <script>
    const svg = d3.select("#chart"),
          width = +svg.attr("width"),
          height = +svg.attr("height"),
          margin = {top: 40, right: 40, bottom: 40, left: 80};

    const parseTime = d3.timeParse("%H:%M");
    const parseDate = d3.timeParse("%m/%d/%Y");
    const ninetyMin = 90 * 60 * 1000;

    Promise.all([
      d3.csv("https://raw.githubusercontent.com/EDCStanalytics/CruiseData/refs/heads/main/Actuals/CallData_Cruise.csv"),
      d3.csv("https://raw.githubusercontent.com/EDCStanalytics/CruiseData/refs/heads/main/Actuals/ShorePowerData_Cruise.csv")
    ]).then(([callData, shorePower]) => {

      const shoreLookup = new Map(
        shorePower.map(d => [d.CallID, { connect: d.Connect, disconnect: d.Disconnect}])
      );

      const data = callData.map(d => {
        const sp = shoreLookup.get(d.CallID);
        const connectObj = sp && sp.connect ? parseTime(sp.connect) : null;
        const disconnectObj = sp && sp.disconnect ? parseTime(sp.disconnect) : null;
        const dateObj = parseDate(d.ArrivalDate);
        const arriveObj = d.Arrival ? parseTime(d.Arrival) : null;
        const departObj = d.Depart ? parseTime(d.Depart) : null;

        const arr = new Date(d.ArrivalDate);
        const dep = new Date(d.DepartDate);
        const diff = dep - arr;
        const diff2 = diff/(1000 * 60 * 60 * 24);
        const correction = diff2 * 86400000;

        return {
          CallID: d.CallID,
          dateObj,
          month: dateObj ? dateObj.getMonth() : null,
          year: dateObj ? dateObj.getFullYear() : null,
          arriveObj,
          departObj,
          connectObj,
          disconnectObj,
          ninetyAfter: arriveObj ? new Date(+arriveObj + ninetyMin) : null,
          ninetyBefore: departObj ? new Date((diff2 > 0 ? +departObj + correction : +departObj) - ninetyMin) : null,
          VesselName: d.VesselName || "Unknown",
          diff2,
          correction
        };
      });
      
data.sort((a, b) => d3.ascending(a.year, b.year) || d3.ascending(a.month, b.month));


      // Assign index within each month
      const grouped = d3.group(data.filter(d => d.month!=null), d => d.month);
      grouped.forEach((rows, m) => {
        rows.forEach((row, i) => row.callIndex = i);
      });

      const months = d3.range(0,12);
      const xMonth = d3.scaleBand()
        .domain(months)
        .range([margin.left, width - margin.right])
        .paddingInner(0.1);

      const maxCalls = d3.max(Array.from(grouped.values(), v => v.length));
      const xCall = d3.scaleBand()
        .domain(d3.range(maxCalls))
        .range([0, xMonth.bandwidth()])
        .padding(0.1);

      const y = d3.scaleTime()
        .domain([parseTime("02:00"), parseTime("23:59")])
        .range([height - margin.bottom, margin.top]);

      // Axis
      svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xMonth)
          .tickFormat(i => d3.timeFormat("%b")(new Date(2000, i, 1))));

      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).tickFormat(d3.timeFormat("%H:%M")).ticks(9));

      // Helper to center clusters
      function clusterOffset(month) {
        const callsInMonth = grouped.get(month)?.length || 0;
        const clusterWidth = callsInMonth * xCall.bandwidth();
        return (xMonth.bandwidth() - clusterWidth) / 2;
      }

      // Rectangles
      const rects = svg.selectAll("rect.conn")
        .data(data.filter(d => d.connectObj && d.disconnectObj && d.month!=null))
        .enter().append("rect")
        .attr("class", "conn")
        .attr("x", d => xMonth(d.month) + clusterOffset(d.month) + xCall(d.callIndex))
        .attr("width", xCall.bandwidth())
        .attr("y", d => y(d.disconnectObj))
        .attr("height", d => Math.abs(y(d.connectObj) - y(d.disconnectObj)))
        .attr("rx", 6).attr("ry", 6);

      // Vertical line rectangles
      const lineWidth = Math.max(2, xCall.bandwidth() * 0.1);
      const adRects = svg.selectAll("rect.ad")
  .data(data.filter(d => d.arriveObj && d.departObj && d.month!=null))
  .enter().append("rect")
  .attr("class", "ad")
  .attr("x", d => xMonth(d.month) + clusterOffset(d.month) + xCall(d.callIndex) + (xCall.bandwidth()-lineWidth)/2)
  .attr("width", lineWidth)
  .attr("y", d => y(d.diff2 > 0 ? new Date(+d.departObj + d.correction) : d.departObj))
  .attr("height", d => d.diff2 > 0
    ? y(d.arriveObj) - y(new Date(+d.departObj + d.correction))
    : y(d.arriveObj) - y(d.departObj))
  .attr("fill",d => d.year === 2025 ? "blue" : "red");  // <-- color by year


      // Dots
      svg.selectAll("circle.after")
        .data(data.filter(d => d.ninetyAfter && d.month!=null))
        .enter().append("circle")
        .attr("class", "after")
        .attr("cx", d => xMonth(d.month) + clusterOffset(d.month) + xCall(d.callIndex) + xCall.bandwidth()/2)
        .attr("cy", d => y(d.ninetyAfter))
        .attr("r", 4);

      svg.selectAll("circle.before")
        .data(data.filter(d => d.ninetyBefore && d.month!=null))
        .enter().append("circle")
        .attr("class", "before")
        .attr("cx", d => xMonth(d.month) + clusterOffset(d.month) + xCall(d.callIndex) + xCall.bandwidth()/2)
        .attr("cy", d => y(d.ninetyBefore))
        .attr("r", 4);

      // Dropdown
      const vesselName = Array.from(new Set(data.map(d => d.VesselName))).filter(Boolean);
      const select = d3.select("#vesselSelect");
      select.append("option").text("All Vessels").attr("value", "all");
      vesselName.forEach(name => select.append("option").text(name).attr("value", name));

      select.on("change", function() {
        const selectedName = this.value;
        rects.transition().duration(800)
          .style("opacity", d => (selectedName==="all" || d.VesselName===selectedName)?1:0);
        adRects.transition().duration(800)
          .style("opacity", d => (selectedName==="all" || d.VesselName===selectedName)?1:0);
        svg.selectAll("circle.after").transition().duration(800)
          .style("opacity", d => (selectedName==="all" || d.VesselName===selectedName)?1:0);
        svg.selectAll("circle.before").transition().duration(800)
          .style("opacity", d => (selectedName==="all" || d.VesselName===selectedName)?1:0);
      });
    });
  </script>
</body>
</html>
